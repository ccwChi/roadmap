# 3D 網狀圖功能規劃

## 📋 功能需求總覽

### 核心功能
1. ✅ 使用者自建流程圖（拖曳建立節點與連線）
2. ✅ 卡片點擊展開 Modal（支援 Markdown 長內容）
3. ✅ 文字內連結（Markdown 中可連結到其他卡片）
4. ⚠️ 3D 網狀視覺化（需效能優化）
5. ✅ 資料同步（Zustand + Google Drive）
6. ✅ 記憶體管理（按需載入內容）

---

## 🎨 技術方案

### 1. 3D 視覺化套件選擇

#### 推薦方案：react-force-graph-3d

**安裝**：
```bash
npm install react-force-graph-3d three
npm install @types/three --save-dev
```

**特點**：
- 基於 Three.js 和 D3 force simulation
- 自動力導向佈局
- 支援大量節點（100+ 節點仍流暢）
- 內建縮放、旋轉、點擊互動

**效能評估**：
| 裝置類型 | 節點數量 | 預期效能 |
|---------|---------|---------|
| 桌面（高階） | 100+ | 流暢 60fps |
| 桌面（中階） | 50-100 | 流暢 30-60fps |
| 手機（高階） | 50 | 可接受 30fps |
| 手機（中階） | 30 | 可能卡頓 15-30fps |

#### 備用方案：響應式降級

```javascript
const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
const nodeLimit = isMobile ? 30 : 100;

// 手機自動切換到 2D 模式
const GraphComponent = isMobile ? ForceGraph2D : ForceGraph3D;
```

---

## 📦 資料結構設計

### 卡片資料結構

```javascript
{
  // 基本資訊
  id: 'card-uuid-1',
  title: '卡片標題',
  createdAt: '2026-01-04T10:00:00Z',
  updatedAt: '2026-01-04T10:30:00Z',
  
  // 顯示內容
  summary: [
    '大項目 1',
    '大項目 2',
    '大項目 3'
  ], // 顯示在卡片上
  
  // 完整內容（僅在 Modal 載入）
  content: `
# 卡片標題

## 大項目 1
詳細內容...

## 大項目 2
更多內容...

可以連結到其他卡片：[[card-uuid-2]]
或使用 Markdown 語法：[查看相關內容](card://card-uuid-3)
  `,
  
  // 連結關係
  links: [
    {
      targetId: 'card-uuid-2',
      type: 'reference', // reference, prerequisite, related
      label: '參考資料'
    },
    {
      targetId: 'card-uuid-3',
      type: 'prerequisite',
      label: '前置知識'
    }
  ],
  
  // 視覺化位置（3D 座標，可選）
  position: {
    x: 0,
    y: 0,
    z: 0
  },
  
  // 標籤分類
  tags: ['AI', 'Machine Learning', 'Python'],
  
  // 顏色（用於視覺化）
  color: '#3b82f6'
}
```

### Graph 資料結構（Force Graph 格式）

```javascript
{
  nodes: [
    {
      id: 'card-uuid-1',
      name: '卡片標題',
      summary: ['項目1', '項目2'],
      color: '#3b82f6',
      val: 10 // 節點大小
    }
  ],
  links: [
    {
      source: 'card-uuid-1',
      target: 'card-uuid-2',
      type: 'reference',
      label: '參考資料',
      color: '#94a3b8' // 連線顏色
    }
  ]
}
```

---

## 🔧 實作細節

### 1. 使用者建立卡片流程

```
1. 點擊「新增卡片」按鈕
   ↓
2. 開啟編輯 Modal
   - 輸入標題
   - 輸入大項目（顯示在卡片上）
   - 編輯 Markdown 內容
   ↓
3. 儲存到 Zustand store
   ↓
4. 更新 3D Graph 視圖
   ↓
5. 觸發雲端同步
```

### 2. Markdown 內連結解析

**語法設計**：
```markdown
# 標題

這是一段文字，可以連結到 [[另一張卡片的ID]] 或使用
[友善的連結文字](card://card-uuid-2)。

## 大項目
更多內容...
```

**解析實作**：
```javascript
// 使用 react-markdown + remark-gfm
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';

// 自訂連結渲染器
const MarkdownRenderer = ({ content, onCardClick }) => {
  return (
    <ReactMarkdown
      remarkPlugins={[remarkGfm]}
      components={{
        a: ({ node, href, children, ...props }) => {
          // 處理 card:// 協議
          if (href?.startsWith('card://')) {
            const cardId = href.replace('card://', '');
            return (
              <button
                onClick={() => onCardClick(cardId)}
                className="text-blue-500 underline hover:text-blue-700"
                {...props}
              >
                {children}
              </button>
            );
          }
          // 一般連結
          return <a href={href} target="_blank" rel="noopener noreferrer" {...props}>{children}</a>;
        }
      }}
    >
      {content}
    </ReactMarkdown>
  );
};

// 解析 [[card-id]] 語法
const parseWikiLinks = (markdown) => {
  return markdown.replace(/\[\[([^\]]+)\]\]/g, (match, cardId) => {
    return `[${cardId}](card://${cardId})`;
  });
};
```

### 3. 隱藏連線顯示

**切換顯示模式**：
```javascript
const [showHiddenLinks, setShowHiddenLinks] = useState(false);

// 過濾連線
const visibleLinks = useMemo(() => {
  return allLinks.filter(link => {
    if (showHiddenLinks) return true;
    return link.type !== 'hidden'; // 只顯示非隱藏連線
  });
}, [allLinks, showHiddenLinks]);
```

**視覺化區分**：
- 明確連線：實線，較粗
- 隱藏連線（文字內連結）：虛線，較細，半透明

---

## 💾 記憶體管理策略

### 問題分析

**資料量估算**：
- 50 張卡片 × 2000 字 = 100,000 字
- 假設平均每字 2 bytes（UTF-8）= 200 KB
- 加上 JSON 結構 ≈ 300-500 KB

**結論**：資料量不大，主要問題是 **DOM 渲染**

### 解決方案

#### 1. 按需載入內容（Lazy Loading）

```javascript
// Zustand Store 設計
const useCardStore = create(
  persist(
    (set, get) => ({
      // 僅儲存卡片元資料
      cards: {
        'card-1': {
          id: 'card-1',
          title: '標題',
          summary: ['項目1', '項目2'],
          links: ['card-2'],
          contentLoaded: false // 標記內容是否已載入
        }
      },
      
      // 完整內容分開儲存（不持久化到 localStorage）
      cardContents: {},
      
      // 載入卡片內容
      loadCardContent: async (cardId) => {
        const { cardContents } = get();
        if (cardContents[cardId]) return; // 已載入
        
        // 從 Google Drive 或 IndexedDB 載入
        const content = await fetchCardContent(cardId);
        set(state => ({
          cardContents: {
            ...state.cardContents,
            [cardId]: content
          },
          cards: {
            ...state.cards,
            [cardId]: {
              ...state.cards[cardId],
              contentLoaded: true
            }
          }
        }));
      },
      
      // 卸載卡片內容（釋放記憶體）
      unloadCardContent: (cardId) => {
        set(state => {
          const newContents = { ...state.cardContents };
          delete newContents[cardId];
          return {
            cardContents: newContents,
            cards: {
              ...state.cards,
              [cardId]: {
                ...state.cards[cardId],
                contentLoaded: false
              }
            }
          };
        });
      }
    }),
    {
      name: 'card-storage',
      partialize: (state) => ({
        // 只持久化元資料，不持久化完整內容
        cards: Object.fromEntries(
          Object.entries(state.cards).map(([id, card]) => [
            id,
            {
              id: card.id,
              title: card.title,
              summary: card.summary,
              links: card.links,
              position: card.position,
              tags: card.tags,
              color: card.color
            }
          ])
        )
      })
    }
  )
);
```

#### 2. Modal 生命週期管理

```javascript
const CardModal = ({ cardId, onClose }) => {
  const loadCardContent = useCardStore(state => state.loadCardContent);
  const unloadCardContent = useCardStore(state => state.unloadCardContent);
  const content = useCardStore(state => state.cardContents[cardId]);
  
  useEffect(() => {
    // Modal 開啟時載入內容
    loadCardContent(cardId);
    
    // Modal 關閉時卸載內容（可選，根據需求）
    return () => {
      // 延遲卸載，避免快速開關時重複載入
      setTimeout(() => {
        unloadCardContent(cardId);
      }, 5000); // 5 秒後卸載
    };
  }, [cardId]);
  
  if (!content) {
    return <div>載入中...</div>;
  }
  
  return (
    <Dialog open onOpenChange={onClose}>
      <MarkdownRenderer content={content} />
    </Dialog>
  );
};
```

#### 3. IndexedDB 儲存完整內容

```javascript
// 使用 IndexedDB 儲存大量內容
const DB_NAME = 'roadmap-cards-db';
const STORE_NAME = 'card-contents';

const openDB = () => {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, 1);
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
      }
    };
    
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
};

const saveCardContent = async (cardId, content) => {
  const db = await openDB();
  const tx = db.transaction(STORE_NAME, 'readwrite');
  const store = tx.objectStore(STORE_NAME);
  await store.put({ id: cardId, content, updatedAt: Date.now() });
};

const loadCardContent = async (cardId) => {
  const db = await openDB();
  const tx = db.transaction(STORE_NAME, 'readonly');
  const store = tx.objectStore(STORE_NAME);
  const result = await store.get(cardId);
  return result?.content;
};
```

---

## 🎮 3D Graph 實作範例

### 基本設定

```javascript
import ForceGraph3D from 'react-force-graph-3d';
import { useRef, useCallback, useMemo } from 'react';

const Graph3DView = ({ cards, onCardClick }) => {
  const graphRef = useRef();
  
  // 轉換資料格式
  const graphData = useMemo(() => {
    const nodes = Object.values(cards).map(card => ({
      id: card.id,
      name: card.title,
      summary: card.summary,
      color: card.color || '#3b82f6',
      val: 10 // 節點大小
    }));
    
    const links = [];
    Object.values(cards).forEach(card => {
      card.links?.forEach(link => {
        links.push({
          source: card.id,
          target: link.targetId,
          type: link.type,
          label: link.label,
          color: link.type === 'hidden' ? '#94a3b880' : '#94a3b8'
        });
      });
    });
    
    return { nodes, links };
  }, [cards]);
  
  // 節點點擊
  const handleNodeClick = useCallback((node) => {
    onCardClick(node.id);
  }, [onCardClick]);
  
  // 自訂節點外觀
  const nodeThreeObject = useCallback((node) => {
    // 使用 Three.js 建立自訂 3D 物件
    const sprite = new SpriteText(node.name);
    sprite.color = node.color;
    sprite.textHeight = 8;
    return sprite;
  }, []);
  
  return (
    <ForceGraph3D
      ref={graphRef}
      graphData={graphData}
      nodeLabel="name"
      nodeColor="color"
      nodeVal="val"
      nodeThreeObject={nodeThreeObject}
      onNodeClick={handleNodeClick}
      linkColor="color"
      linkLabel="label"
      linkWidth={2}
      linkDirectionalParticles={2}
      linkDirectionalParticleSpeed={0.005}
      backgroundColor="#0a0a0a"
      showNavInfo={false}
      enableNodeDrag={true}
      enableNavigationControls={true}
    />
  );
};
```

### 效能優化

```javascript
// 1. 節點數量限制
const MAX_NODES_MOBILE = 30;
const MAX_NODES_DESKTOP = 100;

const limitedCards = useMemo(() => {
  const limit = isMobile ? MAX_NODES_MOBILE : MAX_NODES_DESKTOP;
  return Object.values(cards).slice(0, limit);
}, [cards, isMobile]);

// 2. LOD (Level of Detail)
const nodeThreeObject = useCallback((node) => {
  const distance = graphRef.current?.camera()?.position.distanceTo(node);
  
  if (distance > 500) {
    // 遠距離：簡單的點
    return new THREE.Mesh(
      new THREE.SphereGeometry(5),
      new THREE.MeshBasicMaterial({ color: node.color })
    );
  } else {
    // 近距離：詳細的文字
    const sprite = new SpriteText(node.name);
    sprite.color = node.color;
    sprite.textHeight = 8;
    return sprite;
  }
}, []);

// 3. 降低渲染品質（手機）
const engineConfig = useMemo(() => {
  if (isMobile) {
    return {
      numDimensions: 3,
      cooldownTicks: 100, // 減少模擬迭代
      d3AlphaDecay: 0.05, // 加快收斂
      d3VelocityDecay: 0.3
    };
  }
  return {};
}, [isMobile]);
```

---

## 🔄 資料同步策略

### Google Drive 儲存結構

```
AI-Roadmap-Data/
├── roadmap-data.json          # 原有的 roadmap 資料
└── cards/
    ├── metadata.json          # 所有卡片的元資料
    ├── card-uuid-1.json       # 卡片 1 的完整內容
    ├── card-uuid-2.json       # 卡片 2 的完整內容
    └── ...
```

### 同步邏輯

```javascript
// 1. 初次載入：只載入 metadata
const loadCardsMetadata = async () => {
  const metadata = await loadData('cards/metadata.json');
  set({ cards: metadata });
};

// 2. 開啟 Modal：載入單張卡片內容
const loadCardContent = async (cardId) => {
  const content = await loadData(`cards/${cardId}.json`);
  set(state => ({
    cardContents: { ...state.cardContents, [cardId]: content }
  }));
};

// 3. 編輯卡片：更新 metadata 和內容
const updateCard = async (cardId, updates) => {
  // 更新本地
  set(state => ({
    cards: {
      ...state.cards,
      [cardId]: { ...state.cards[cardId], ...updates.metadata }
    },
    cardContents: {
      ...state.cardContents,
      [cardId]: updates.content
    }
  }));
  
  // 同步到雲端
  await saveData(`cards/metadata.json`, get().cards);
  await saveData(`cards/${cardId}.json`, updates.content);
};
```

---

## 📱 響應式設計

### 裝置偵測與自動降級

```javascript
const useDeviceType = () => {
  const [deviceType, setDeviceType] = useState('desktop');
  
  useEffect(() => {
    const checkDevice = () => {
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      const isTablet = /(iPad|Android(?!.*Mobile))/i.test(navigator.userAgent);
      
      if (isMobile) setDeviceType('mobile');
      else if (isTablet) setDeviceType('tablet');
      else setDeviceType('desktop');
    };
    
    checkDevice();
    window.addEventListener('resize', checkDevice);
    return () => window.removeEventListener('resize', checkDevice);
  }, []);
  
  return deviceType;
};

// 使用
const GraphView = () => {
  const deviceType = useDeviceType();
  
  if (deviceType === 'mobile') {
    return <ForceGraph2D {...props} />;
  }
  
  return <ForceGraph3D {...props} />;
};
```

### 效能監控

```javascript
const usePerformanceMonitor = () => {
  const [fps, setFps] = useState(60);
  
  useEffect(() => {
    let frameCount = 0;
    let lastTime = performance.now();
    
    const measureFPS = () => {
      frameCount++;
      const currentTime = performance.now();
      
      if (currentTime >= lastTime + 1000) {
        setFps(frameCount);
        frameCount = 0;
        lastTime = currentTime;
      }
      
      requestAnimationFrame(measureFPS);
    };
    
    measureFPS();
  }, []);
  
  return fps;
};

// 自動降級
const GraphView = () => {
  const fps = usePerformanceMonitor();
  const [use3D, setUse3D] = useState(true);
  
  useEffect(() => {
    // FPS 低於 20 自動切換到 2D
    if (fps < 20 && use3D) {
      setUse3D(false);
      console.warn('效能不足，自動切換到 2D 模式');
    }
  }, [fps, use3D]);
  
  return use3D ? <ForceGraph3D /> : <ForceGraph2D />;
};
```

---

## 🎨 UI/UX 設計建議

### 1. 卡片設計

```
┌─────────────────────────┐
│ 📌 卡片標題             │
├─────────────────────────┤
│ • 大項目 1              │
│ • 大項目 2              │
│ • 大項目 3              │
├─────────────────────────┤
│ 🔗 3 個連結             │
│ 🏷️ AI, Python          │
└─────────────────────────┘
```

### 2. Modal 設計

```
┌──────────────────────────────────────┐
│ ← 返回    卡片標題           ⚙️ 編輯 │
├──────────────────────────────────────┤
│                                      │
│  # Markdown 內容                     │
│                                      │
│  ## 大項目 1                         │
│  詳細內容...                         │
│                                      │
│  可以連結到 [[其他卡片]]             │
│                                      │
├──────────────────────────────────────┤
│ 🔗 連結到的卡片：                    │
│  • 卡片 A                            │
│  • 卡片 B                            │
└──────────────────────────────────────┘
```

### 3. 工具列

```
┌─────────────────────────────────────┐
│ ➕ 新增卡片  🔍 搜尋  🎨 2D/3D 切換 │
│ 👁️ 顯示隱藏連線  📊 統計資訊        │
└─────────────────────────────────────┘
```

---

## 📊 開發階段規劃

### Phase 1: 基礎功能（2-3 週）
- [ ] 卡片資料結構設計
- [ ] Zustand store 重構（支援卡片管理）
- [ ] 基本 CRUD 功能（新增、編輯、刪除卡片）
- [ ] Markdown 編輯器整合
- [ ] Modal 元件開發

### Phase 2: 2D 視覺化（1-2 週）
- [ ] 整合 react-force-graph-2d
- [ ] 節點與連線渲染
- [ ] 互動功能（點擊、拖曳）
- [ ] 連線建立介面

### Phase 3: 3D 視覺化（2-3 週）
- [ ] 整合 react-force-graph-3d
- [ ] 3D 節點自訂渲染
- [ ] 效能優化（LOD、限制節點數）
- [ ] 響應式降級機制

### Phase 4: 進階功能（2-3 週）
- [ ] Markdown 內連結解析
- [ ] 隱藏連線顯示/隱藏
- [ ] 記憶體管理（按需載入）
- [ ] IndexedDB 整合

### Phase 5: 雲端同步（1-2 週）
- [ ] Google Drive 多檔案儲存
- [ ] 增量同步機制
- [ ] 衝突解決

### Phase 6: 優化與測試（1-2 週）
- [ ] 效能測試與優化
- [ ] 手機適配
- [ ] 使用者測試
- [ ] Bug 修復

**總計：9-15 週**

---

## ⚠️ 風險與挑戰

### 1. 效能風險
- **問題**：50+ 節點的 3D 渲染在手機上可能卡頓
- **解決**：自動降級到 2D、節點數量限制、LOD

### 2. 記憶體風險
- **問題**：大量 Markdown 內容可能佔用記憶體
- **解決**：按需載入、IndexedDB 儲存、定期清理

### 3. 同步複雜度
- **問題**：多檔案同步可能出現衝突
- **解決**：使用時間戳、版本號、衝突提示

### 4. 使用者體驗
- **問題**：3D 操作學習曲線較陡
- **解決**：提供教學、2D/3D 切換、預設使用 2D

---

## 🎯 總結與建議

### ✅ 可行性評估

| 功能 | 可行性 | 難度 | 建議 |
|-----|-------|------|-----|
| 使用者自建流程圖 | ✅ 高 | 中 | 使用 ReactFlow 或 Force Graph |
| Markdown Modal | ✅ 高 | 低 | 使用 react-markdown |
| 文字內連結 | ✅ 高 | 中 | 自訂 Markdown 解析器 |
| 3D 網狀圖 | ⚠️ 中 | 高 | 桌面可行，手機需降級 |
| 資料同步 | ✅ 高 | 中 | 延續現有機制 |
| 記憶體管理 | ✅ 高 | 中 | 按需載入 + IndexedDB |

### 💡 最終建議

1. **先做 2D 版本**：驗證核心功能和使用者需求
2. **再加 3D 視覺化**：作為進階功能，可選擇開啟
3. **效能優先**：確保手機流暢比酷炫效果更重要
4. **漸進式開發**：按階段實作，每階段都可用

### 🚀 下一步行動

建議您先：
1. 安裝 `react-force-graph-2d` 和 `react-markdown`
2. 建立基本的卡片 CRUD 功能
3. 實作 2D 視覺化
4. 測試效能後再決定是否加入 3D

**3D 網狀圖是可以達成的，但需要謹慎的效能優化和降級策略！**
