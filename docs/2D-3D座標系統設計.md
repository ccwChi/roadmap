# 2D/3D åº§æ¨™ç³»çµ±è¨­è¨ˆèªªæ˜

## ğŸ¯ è¨­è¨ˆæ±ºç­–ï¼šçµ±ä¸€ä½¿ç”¨ 3D åº§æ¨™

### æ ¸å¿ƒåŸå‰‡

**æ‰€æœ‰å¡ç‰‡ä½ç½®çµ±ä¸€ä½¿ç”¨ 3D åº§æ¨™ `{ x, y, z }`**
- 2D æ¨¡å¼ï¼šz å›ºå®šç‚º 0
- 3D æ¨¡å¼ï¼šz ç”±åŠ›å°å‘æ¼”ç®—æ³•è¨ˆç®—

---

## ğŸ“ åº§æ¨™ç³»çµ±

### åº§æ¨™å®šç¾©

```javascript
position: {
  x: number,  // æ°´å¹³ä½ç½®ï¼ˆå·¦å³ï¼‰
  y: number,  // å‚ç›´ä½ç½®ï¼ˆä¸Šä¸‹ï¼‰
  z: number   // æ·±åº¦ä½ç½®ï¼ˆå‰å¾Œï¼Œ2D æ™‚å›ºå®šç‚º 0ï¼‰
}
```

### åº§æ¨™ç¯„åœ

**2D æ¨¡å¼**ï¼š
- x: -âˆ to +âˆï¼ˆReactFlow ç„¡é™ç•«å¸ƒï¼‰
- y: -âˆ to +âˆ
- z: 0ï¼ˆå›ºå®šï¼‰

**3D æ¨¡å¼**ï¼š
- x: -âˆ to +âˆ
- y: -âˆ to +âˆ
- z: -âˆ to +âˆï¼ˆç”±åŠ›å°å‘æ¼”ç®—æ³•æ±ºå®šï¼‰

---

## ğŸ”„ 2D/3D è½‰æ›

### å¾ 2D åˆ‡æ›åˆ° 3D

```javascript
// æ–¹æ³• 1: ä¿æŒ 2D ä½ˆå±€ï¼Œz åº§æ¨™ç”±æ¼”ç®—æ³•è¨ˆç®—
const switch2Dto3D = (cards) => {
  // ä¸éœ€è¦åšä»»ä½•äº‹ï¼
  // D3-force-3d æœƒè‡ªå‹•ç‚º z åº§æ¨™è³¦å€¼
  return cards;
};

// æ–¹æ³• 2: æ ¹æ“šæŸäº›è¦å‰‡è¨­å®šåˆå§‹ z å€¼
const switch2Dto3DWithLogic = (cards) => {
  return cards.map(card => ({
    ...card,
    position: {
      ...card.position,
      z: calculateInitialZ(card) // ä¾‹å¦‚ï¼šæ ¹æ“šæ¨™ç±¤ã€é€£çµæ•¸ç­‰
    }
  }));
};

function calculateInitialZ(card) {
  // ç¯„ä¾‹ï¼šæ ¹æ“šé€£çµæ•¸æ±ºå®šæ·±åº¦
  const linkCount = card.links.length;
  return linkCount * 10; // é€£çµè¶Šå¤šè¶Šé å‰
}
```

### å¾ 3D åˆ‡æ›åˆ° 2D

```javascript
const switch3Dto2D = (cards) => {
  return cards.map(card => ({
    ...card,
    position: {
      x: card.position.x,
      y: card.position.y,
      z: 0  // é‡ç½®ç‚º 0
    }
  }));
};

// æˆ–è€…ä¿ç•™ z å€¼ï¼ˆä¸‹æ¬¡åˆ‡å› 3D æ™‚æ¢å¾©ï¼‰
const switch3Dto2DKeepZ = (cards) => {
  // ä¸éœ€è¦ä¿®æ”¹è³‡æ–™
  // åªæ˜¯æ¸²æŸ“æ™‚å¿½ç•¥ z åº§æ¨™
  return cards;
};
```

---

## ğŸ¨ æ¸²æŸ“å¯¦ä½œ

### ReactFlow (2D)

```javascript
import { ReactFlow } from '@xyflow/react';

const CardGraph2D = () => {
  const cards = useCardStore(state => state.cards);
  
  // è½‰æ›ç‚º ReactFlow ç¯€é»æ ¼å¼
  const nodes = Object.values(cards).map(card => ({
    id: card.id,
    type: 'cardNode',
    data: { ...card },
    position: {
      x: card.position.x,
      y: card.position.y
      // z åº§æ¨™è¢«å¿½ç•¥
    }
  }));
  
  return <ReactFlow nodes={nodes} />;
};
```

### React Three Fiber (3D)

```javascript
import { Canvas } from '@react-three/fiber';

const CardGraph3D = () => {
  const cards = useCardStore(state => state.cards);
  
  return (
    <Canvas>
      {Object.values(cards).map(card => (
        <Node3D
          key={card.id}
          position={[
            card.position.x,
            card.position.y,
            card.position.z  // ä½¿ç”¨ z åº§æ¨™
          ]}
          data={card}
        />
      ))}
    </Canvas>
  );
};
```

---

## ğŸ”§ åŠ›å°å‘æ¼”ç®—æ³•

### D3-force-3d æ•´åˆ

```javascript
import * as d3 from 'd3-force-3d';

const useForceSimulation = (cards, viewMode) => {
  const simulation = useMemo(() => {
    const nodes = Object.values(cards);
    
    // D3-force-3d è‡ªå‹•æ”¯æ´ 3D
    const sim = d3.forceSimulation(nodes)
      .force('link', d3.forceLink(links)
        .id(d => d.id)
        .distance(50))
      .force('charge', d3.forceManyBody()
        .strength(-200))
      .force('center', d3.forceCenter(0, 0, 0));
    
    // 2D æ¨¡å¼ï¼šé™åˆ¶ z è»¸
    if (viewMode === '2d') {
      sim.force('z', d3.forceZ(0).strength(1)); // å¼·åˆ¶ z = 0
    }
    
    return sim;
  }, [cards, viewMode]);
  
  return simulation;
};
```

### 2D æ¨¡å¼çš„ z è»¸é™åˆ¶

```javascript
// æ–¹æ³• 1: ä½¿ç”¨ forceZ
simulation.force('z', d3.forceZ(0).strength(1));

// æ–¹æ³• 2: åœ¨æ¯æ¬¡ tick å¾Œé‡ç½®
simulation.on('tick', () => {
  if (viewMode === '2d') {
    nodes.forEach(node => {
      node.z = 0;  // å¼·åˆ¶è¨­ç‚º 0
    });
  }
});

// æ–¹æ³• 3: ä½¿ç”¨ 2D ç‰ˆæœ¬çš„ d3-force
import * as d3_2d from 'd3-force';
const simulation2D = d3_2d.forceSimulation(nodes);
// é€™æ¨£ç¯€é»åªæœƒæœ‰ x, yï¼Œä½†éœ€è¦é¡å¤–è™•ç†
```

---

## ğŸ’¾ è³‡æ–™å„²å­˜

### LocalStorage / IndexedDB

```javascript
// å„²å­˜æ™‚ï¼šå®Œæ•´å„²å­˜ 3D åº§æ¨™
const saveCards = (cards) => {
  localStorage.setItem('cards', JSON.stringify(cards));
  // { x: 100, y: 200, z: 0 } æˆ– { x: 100, y: 200, z: 50 }
};

// è¼‰å…¥æ™‚ï¼šä¸éœ€è¦è½‰æ›
const loadCards = () => {
  const data = localStorage.getItem('cards');
  return JSON.parse(data);
  // ç›´æ¥ä½¿ç”¨ï¼Œç„¡éœ€è™•ç†
};
```

### Google Drive

```javascript
// åŒæ­¥åˆ°é›²ç«¯ï¼šå®Œæ•´åŒæ­¥ 3D åº§æ¨™
const syncToCloud = async (cards) => {
  await saveData({
    cards: Object.values(cards).map(card => ({
      ...card,
      position: card.position  // { x, y, z }
    }))
  });
};

// å¾é›²ç«¯è¼‰å…¥ï¼šä¸éœ€è¦è½‰æ›
const loadFromCloud = async () => {
  const data = await loadData();
  return data.cards;
  // ç›´æ¥ä½¿ç”¨
};
```

---

## ğŸ® ä½¿ç”¨è€…äº’å‹•

### æ‹–æ›³ç¯€é»

**2D æ¨¡å¼ï¼ˆReactFlowï¼‰**ï¼š
```javascript
const onNodeDragStop = (event, node) => {
  updateNodePosition(node.id, {
    x: node.position.x,
    y: node.position.y,
    z: 0  // ä¿æŒç‚º 0
  });
};
```

**3D æ¨¡å¼ï¼ˆReact Three Fiberï¼‰**ï¼š
```javascript
const Node3D = ({ card }) => {
  const [position, setPosition] = useState([
    card.position.x,
    card.position.y,
    card.position.z
  ]);
  
  const bind = useDrag(({ offset: [x, y] }) => {
    // 3D æ‹–æ›³æ¯”è¼ƒè¤‡é›œï¼Œéœ€è¦æŠ•å½±è¨ˆç®—
    const newPos = calculateDragPosition(x, y, camera);
    setPosition(newPos);
    updateNodePosition(card.id, {
      x: newPos[0],
      y: newPos[1],
      z: newPos[2]
    });
  });
  
  return <mesh position={position} {...bind()} />;
};
```

---

## ğŸ“Š æ•ˆèƒ½è€ƒé‡

### è¨˜æ†¶é«”ä½¿ç”¨

```javascript
// 2D åº§æ¨™
position: { x: 100, y: 200 }
// è¨˜æ†¶é«”ï¼š2 å€‹ number = 16 bytes

// 3D åº§æ¨™
position: { x: 100, y: 200, z: 0 }
// è¨˜æ†¶é«”ï¼š3 å€‹ number = 24 bytes

// å·®ç•°ï¼šæ¯å€‹å¡ç‰‡å¤š 8 bytes
// 100 å€‹å¡ç‰‡ï¼š800 bytes = 0.8 KB
// çµè«–ï¼šå¯ä»¥å¿½ç•¥ä¸è¨ˆ
```

### è¨ˆç®—æ•ˆèƒ½

```javascript
// 2D åŠ›å°å‘
d3.forceSimulation(nodes)  // è¨ˆç®— x, y

// 3D åŠ›å°å‘
d3.forceSimulation(nodes)  // è¨ˆç®— x, y, z

// å·®ç•°ï¼šç´„ 20-30% è¨ˆç®—é‡å¢åŠ 
// ä½†åœ¨ç¾ä»£é›»è…¦ä¸Šå®Œå…¨å¯æ¥å—
// è€Œä¸” 2D æ¨¡å¼å¯ä»¥é™åˆ¶ z è»¸
```

---

## ğŸ”„ é·ç§»ç­–ç•¥ï¼ˆå¦‚æœå·²æœ‰èˆŠè³‡æ–™ï¼‰

### æƒ…å¢ƒï¼šå·²æœ‰ä½¿ç”¨ 2D åº§æ¨™çš„å¡ç‰‡

```javascript
// é·ç§»å‡½æ•¸
const migrateCardsTo3D = (cards) => {
  return cards.map(card => {
    // æª¢æŸ¥æ˜¯å¦å·²æœ‰ z åº§æ¨™
    if (card.position.z !== undefined) {
      return card; // å·²ç¶“æ˜¯ 3Dï¼Œä¸éœ€è¦é·ç§»
    }
    
    // åŠ å…¥ z åº§æ¨™
    return {
      ...card,
      position: {
        ...card.position,
        z: 0  // é è¨­ç‚º 0
      }
    };
  });
};

// åœ¨ Store åˆå§‹åŒ–æ™‚åŸ·è¡Œ
export const useCardStore = create(
  persist(
    (set, get) => ({
      // ... å…¶ä»–ç‹€æ…‹
    }),
    {
      name: 'card-storage',
      onRehydrateStorage: () => (state) => {
        // è¼‰å…¥å¾Œè‡ªå‹•é·ç§»
        if (state?.cards) {
          const migratedCards = {};
          Object.entries(state.cards).forEach(([id, card]) => {
            migratedCards[id] = {
              ...card,
              position: {
                x: card.position.x || 0,
                y: card.position.y || 0,
                z: card.position.z ?? 0  // ä½¿ç”¨ ?? ç¢ºä¿ 0 ä¹Ÿè¢«ä¿ç•™
              }
            };
          });
          state.cards = migratedCards;
        }
      }
    }
  )
);
```

---

## ğŸ¨ è¦–è¦ºåŒ–å»ºè­°

### 2D æ¨¡å¼çš„æ·±åº¦æš—ç¤º

å³ä½¿åœ¨ 2D æ¨¡å¼ï¼Œä¹Ÿå¯ä»¥ç”¨è¦–è¦ºæ•ˆæœæš—ç¤ºæ·±åº¦ï¼š

```javascript
const CardNode = ({ card }) => {
  // ä½¿ç”¨ z å€¼ï¼ˆå³ä½¿åœ¨ 2Dï¼‰ä¾†èª¿æ•´è¦–è¦ºæ•ˆæœ
  const depth = card.position.z || 0;
  
  return (
    <div
      style={{
        // æ ¹æ“š z å€¼èª¿æ•´å¤§å°ï¼ˆæ¨¡æ“¬é è¿‘ï¼‰
        transform: `scale(${1 + depth * 0.01})`,
        
        // æ ¹æ“š z å€¼èª¿æ•´é€æ˜åº¦
        opacity: 1 - Math.abs(depth) * 0.002,
        
        // æ ¹æ“š z å€¼èª¿æ•´é™°å½±
        boxShadow: `0 ${depth * 0.1}px ${depth * 0.2}px rgba(0,0,0,0.3)`,
        
        // z-index æ ¹æ“š z å€¼
        zIndex: Math.round(1000 + depth)
      }}
    >
      {/* å¡ç‰‡å…§å®¹ */}
    </div>
  );
};
```

### 3D æ¨¡å¼çš„ 2D æŠ•å½±

åœ¨ 3D æ¨¡å¼ä¸‹ï¼Œå¯ä»¥é¡¯ç¤º 2D æŠ•å½±ä½œç‚ºåƒè€ƒï¼š

```javascript
const CardGraph3D = () => {
  return (
    <Canvas>
      {/* 3D ç¯€é» */}
      {cards.map(card => (
        <Node3D key={card.id} position={card.position} />
      ))}
      
      {/* 2D æŠ•å½±ï¼ˆåœ°æ¿ä¸Šçš„å½±å­ï¼‰ */}
      {cards.map(card => (
        <mesh
          key={`shadow-${card.id}`}
          position={[card.position.x, card.position.y, 0]}
          rotation={[-Math.PI / 2, 0, 0]}
        >
          <circleGeometry args={[5, 32]} />
          <meshBasicMaterial color="#000" opacity={0.2} transparent />
        </mesh>
      ))}
    </Canvas>
  );
};
```

---

## ğŸ§ª æ¸¬è©¦å»ºè­°

### å–®å…ƒæ¸¬è©¦

```javascript
describe('Position System', () => {
  test('æ–°å¡ç‰‡æ‡‰è©²æœ‰ 3D åº§æ¨™', () => {
    const card = createCard({ title: 'Test' });
    expect(card.position).toHaveProperty('x');
    expect(card.position).toHaveProperty('y');
    expect(card.position).toHaveProperty('z');
    expect(card.position.z).toBe(0); // é è¨­ç‚º 0
  });
  
  test('2D æ¨¡å¼æ‡‰è©²ä¿æŒ z = 0', () => {
    const cards = [
      { id: '1', position: { x: 0, y: 0, z: 100 } }
    ];
    const result = switch3Dto2D(cards);
    expect(result[0].position.z).toBe(0);
  });
  
  test('3D æ¨¡å¼æ‡‰è©²å…è¨±ä»»æ„ z å€¼', () => {
    const card = { id: '1', position: { x: 0, y: 0, z: 0 } };
    updateNodePosition(card.id, { x: 0, y: 0, z: 50 });
    expect(card.position.z).toBe(50);
  });
});
```

---

## ğŸ“ æœ€ä½³å¯¦è¸

### DO âœ…

1. **çµ±ä¸€ä½¿ç”¨ 3D åº§æ¨™**
   ```javascript
   position: { x: 0, y: 0, z: 0 }
   ```

2. **2D æ¨¡å¼æ™‚æ˜ç¢ºè¨­å®š z = 0**
   ```javascript
   if (viewMode === '2d') {
     card.position.z = 0;
   }
   ```

3. **ä½¿ç”¨è§£æ§‹æ™‚åŒ…å«æ‰€æœ‰åº§æ¨™**
   ```javascript
   const { x, y, z } = card.position;
   ```

4. **æ›´æ–°ä½ç½®æ™‚ä¿æŒå®Œæ•´æ€§**
   ```javascript
   updatePosition({
     ...card.position,
     x: newX  // ä¿ç•™ y, z
   });
   ```

### DON'T âŒ

1. **ä¸è¦æ··ç”¨ 2D å’Œ 3D æ ¼å¼**
   ```javascript
   // âŒ éŒ¯èª¤
   position: { x: 0, y: 0 }        // æŸäº›å¡ç‰‡
   position: { x: 0, y: 0, z: 0 }  // æŸäº›å¡ç‰‡
   ```

2. **ä¸è¦å‡è¨­ z ä¸å­˜åœ¨**
   ```javascript
   // âŒ éŒ¯èª¤
   const { x, y } = card.position;  // å¿½ç•¥ z
   
   // âœ… æ­£ç¢º
   const { x, y, z = 0 } = card.position;
   ```

3. **ä¸è¦åœ¨ 2D æ¨¡å¼ä¸‹ä¿®æ”¹ z å€¼**
   ```javascript
   // âŒ éŒ¯èª¤
   if (viewMode === '2d') {
     card.position.z = Math.random() * 100;
   }
   
   // âœ… æ­£ç¢º
   if (viewMode === '2d') {
     card.position.z = 0;
   }
   ```

---

## ğŸ¯ ç¸½çµ

### ç‚ºä»€éº¼é¸æ“‡çµ±ä¸€ 3D åº§æ¨™ï¼Ÿ

1. âœ… **æœªä¾†è­‰æ˜**ï¼šç‚º 3D åšå¥½æº–å‚™
2. âœ… **é›¶é·ç§»æˆæœ¬**ï¼šä¸éœ€è¦è³‡æ–™è½‰æ›
3. âœ… **ç¨‹å¼ç¢¼ç°¡æ½”**ï¼šä¸éœ€è¦æ¢ä»¶åˆ¤æ–·
4. âœ… **æ•ˆèƒ½å½±éŸ¿å¾®å°**ï¼šæ¯å¡ç‰‡åƒ…å¤š 8 bytes
5. âœ… **D3-force åŸç”Ÿæ”¯æ´**ï¼šç„¡éœ€é¡å¤–è™•ç†

### å¯¦ä½œæª¢æŸ¥æ¸…å–®

- [ ] è³‡æ–™æ¨¡å‹ä½¿ç”¨ `{ x, y, z }`
- [ ] Store é è¨­å€¼åŒ…å« `z: 0`
- [ ] 2D æ¸²æŸ“å¿½ç•¥ z åº§æ¨™
- [ ] 3D æ¸²æŸ“ä½¿ç”¨å®Œæ•´åº§æ¨™
- [ ] åŠ›å°å‘æ¼”ç®—æ³•æ”¯æ´ 2D/3D åˆ‡æ›
- [ ] æ¸¬è©¦è¦†è“‹åº§æ¨™è½‰æ›é‚è¼¯
- [ ] æ–‡ä»¶èªªæ˜åº§æ¨™ç³»çµ±è¨­è¨ˆ

---

**çµè«–ï¼šç¾åœ¨å°±ä½¿ç”¨ 3D åº§æ¨™ï¼Œ2D æ¨¡å¼æ™‚ z å›ºå®šç‚º 0ã€‚é€™æ˜¯æœ€ä½³é¸æ“‡ï¼** âœ¨
